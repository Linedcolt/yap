<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Yap â€” private chats with accounts</title>
<link rel="manifest" id="manifest-placeholder">
<meta name="theme-color" content="#071023" id="meta-theme-color">
<style>
/* ---------- Styles: same look as before, plus auth UI + fixes ---------- */
:root{
  --bg: #f2f4f7; --panel: #ffffff; --accent: #0ea5b7; --muted: #6b7280; --text: #0f172a;
  --safe-area-top: env(safe-area-inset-top, 12px);
  --safe-area-bottom: env(safe-area-inset-bottom, 0px);
  --sms-right-text: #ffffff; /* improved contrast for sent messages */
}
:root[data-theme="dark"]{
  --bg:#071023; --panel:#0b1220; --accent:#06b6d4; --muted:#94a3b8; --text:#e6eef6;
  --sms-right-text: #ffffff;
}
html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased;overscroll-behavior: none}
.app{height:100vh;display:grid;grid-template-rows:var(--safe-area-top) 64px 1fr;gap:0}
header{grid-row:2 / 3;display:flex;align-items:center;padding:0 18px;border-bottom:1px solid rgba(0,0,0,0.06);background:var(--panel);z-index:6}
h1{font-size:20px;margin:0;font-weight:800}
.user-controls{margin-left:auto;display:flex;align-items:center;gap:8px}
.btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
.btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06)}
.btn.primary{background:var(--accent);color:white}
.main{grid-row:3 / 4;display:grid;grid-template-columns:360px 1fr;min-height:0;background:var(--bg)}
.panel{background:var(--panel);border-right:1px solid rgba(0,0,0,0.04);display:flex;flex-direction:column;min-height:0}
.chat-panel{background:var(--panel);display:flex;flex-direction:column;min-height:0}
.rooms-head{display:flex;align-items:center;justify-content:space-between;padding:14px;border-bottom:1px solid rgba(0,0,0,0.03)}
.rooms-list{overflow:auto;-webkit-overflow-scrolling:touch;padding:6px 6px;flex:1;min-height:0}
.room-entry{display:flex;align-items:center;gap:12px;padding:12px;border-radius:12px;cursor:pointer;user-select:none;border-bottom:1px solid rgba(0,0,0,0.02)}
.room-entry:hover{background:rgba(0,0,0,0.03)}
.room-entry.active{background:linear-gradient(90deg, rgba(6,182,212,0.08), rgba(6,182,212,0.02));outline:2px solid rgba(6,182,212,0.08)}
.room-info{flex:1;display:flex;flex-direction:column;min-width:0}
.room-name{font-weight:700;display:flex;align-items:center;gap:8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.room-sub{font-size:12px;color:var(--muted)}
.room-meta{display:flex;flex-direction:column;align-items:flex-end;gap:6px}
.last-snippet{font-size:13px;color:var(--muted);max-width:160px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.last-time{font-size:11px;color:var(--muted)}
.unread{background:var(--accent);color:white;padding:4px 8px;border-radius:999px;font-weight:700;font-size:12px;min-width:28px;text-align:center}
.conv-head{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid rgba(0,0,0,0.03)}
.conv-body{flex:1;overflow:auto;padding:28px 28px 28px 28px;min-height:0;-webkit-overflow-scrolling:touch;overscroll-behavior:contain;background:radial-gradient(circle at 10% 8%, rgba(6,182,212,0.02), transparent 6%),linear-gradient(180deg, rgba(0,0,0,0.01), transparent)}
/* app-like gesture & zoom handling */
html, body { overflow: hidden; touch-action: none; -ms-touch-action: none; }
.conv-body, .rooms-list { touch-action: pan-y; } /* allow vertical scroll only here */
.msg-row{display:flex;gap:10px;align-items:flex-end;margin-bottom:12px;max-width:82%}
.msg-row.me{margin-left:auto;flex-direction:row-reverse}
.avatar{width:44px;height:44px;border-radius:999px;display:inline-flex;align-items:center;justify-content:center;font-weight:700;color:#fff;background:linear-gradient(135deg,var(--accent),#0b7285);flex-shrink:0}
.bubble{padding:12px 14px;border-radius:18px;line-height:1.3;box-shadow:0 8px 24px rgba(2,6,23,0.06)}
.bubble.left{background:#e6eef6;color:var(--text);border-bottom-left-radius:6px}
.bubble.right{background:var(--accent);color:var(--sms-right-text);border-bottom-right-radius:6px}
.bubble.right .meta, .bubble.right .timestamp { color: rgba(255,255,255,0.95); } /* ensure meta/timestamp readable */
.meta{font-size:12px;color:var(--muted);margin-bottom:6px}
.timestamp{font-size:11px;color:var(--muted);margin-top:6px;text-align:right}
/* composer: sticky at bottom, respects safe area inset */
.composer{padding:12px;border-top:1px solid rgba(0,0,0,0.03);display:flex;gap:8px;align-items:center;background:var(--panel); position:sticky; bottom:calc(var(--safe-area-bottom)); z-index:10;}
.composer input[type=text]{flex:1;padding:12px;border-radius:999px;border:1px solid rgba(0,0,0,0.06);background:transparent;color:inherit}
.send-btn{padding:10px 14px;border-radius:999px;border:none;background:var(--accent);color:#fff;font-weight:700}
.context-menu{position:fixed;z-index:9999;background:var(--panel);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.2);min-width:200px;padding:6px;display:none}
.context-item{padding:12px;border-radius:8px;cursor:pointer;font-weight:700}
.context-item:hover{background:rgba(0,0,0,0.04)}
.modal-backdrop{position:fixed;inset:0;background:rgba(2,6,23,0.45);display:none;align-items:center;justify-content:center;z-index:10000}
.modal{width:min(540px,92%);background:var(--panel);border-radius:12px;padding:18px;box-shadow:0 18px 60px rgba(2,6,23,0.45)}
.modal h3{margin:0 0 8px 0}
.modal .row{margin-top:12px;display:flex;gap:8px;align-items:center}
.modal input[type=text], .modal input[type=email], .modal input[type=password]{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)}
.modal .btns{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}
.btn.secondary{background:transparent;border:1px solid rgba(0,0,0,0.06)}
.btn.primary{background:var(--accent);color:white}
.empty-illustration{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--muted)}
.empty-illustration svg{opacity:0.12;margin-bottom:18px}
.empty-illustration h2{margin:0 0 8px 0;font-size:20px}
.empty-illustration p{margin:0;font-size:14px}

/* responsive: DELEGATED to phone detection (so tablets/iPad won't auto-stack) */
@media (max-width:880px){
  /* intentionally empty â€” phone-only layout applied via html.phone class (JS) */
}

/* phone-only responsive override: will be added via JS by setting html.phone */
html.phone .main{ grid-template-columns:1fr; }
html.phone .rooms-list{ display:flex; gap:8px; overflow:auto; padding:10px; flex-wrap:nowrap; }
html.phone .room-entry{ min-width:220px; border-radius:10px; flex:0 0 auto; }
html.phone .conv-body{ padding:18px; }

</style>
</head>
<body>
<div class="app" id="app">
  <div></div>

  <header>
    <div style="display:flex;align-items:center;gap:12px">
      <h1 id="appTitle">Yap</h1>
    </div>

    <div class="user-controls" id="userControls">
      <!-- Auth UI will be injected here -->
      <button id="btnSignIn" class="btn ghost">Sign in</button>
      <button id="btnRegister" class="btn primary">Register</button>
    </div>
  </header>

  <div class="main">
    <aside class="panel" aria-label="Chats">
      <div class="rooms-head">
        <div class="rooms-top-title">
          <div style="font-weight:700">Chats</div>
        </div>
        <div style="display:flex;gap:8px">
          <button id="newRoomBtn" class="btn primary">New</button>
        </div>
      </div>
      <div class="rooms-list" id="roomsList" tabindex="0" aria-live="polite"></div>
    </aside>

    <section class="chat-panel" aria-label="Conversation">
      <div class="conv-head">
        <div style="display:flex;flex-direction:column">
          <div id="currentRoomName" style="font-weight:800">â€”</div>
          <div id="currentUserBadge" style="font-size:12px;color:var(--muted)"></div>
        </div>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center" id="authControls">
          <!-- when signed in, shows username + sign out -->
        </div>
      </div>

      <div id="messages" class="conv-body" aria-live="polite"></div>

      <form id="sendForm" class="composer" onsubmit="return false;">
        <input id="text" type="text" placeholder="" autocomplete="off" />
        <button id="sendBtn" class="send-btn" type="button">Send</button>
      </form>
    </section>
  </div>
</div>

<!-- context menu -->
<div id="contextMenu" class="context-menu" role="menu" aria-hidden="true">
  <div class="context-item" id="ctxOpen">Open</div>
  <div class="context-item" id="ctxRename">Rename</div>
  <div class="context-item" id="ctxInvite">Invite</div>
  <div class="context-item" id="ctxDelete" style="color:#d23f44">Delete Chat</div>
</div>

<!-- modal -->
<div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
  <div class="modal" id="modal"></div>
</div>

<script type="module">
/* ================== CONFIG ================== */
/* keep your project keys here */
const SUPABASE_URL = 'https://vwjibwesyxomcxtyneof.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ3amlid2VzeXhvbWN4dHluZW9mIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEwODE3MjcsImV4cCI6MjA4NjY1NzcyN30.WM17MsaWs1IgA7rmbanztoayBJmk2F2oEpgsqchgXFA';
/* ============================================ */

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* ---------- App-like phone detect & gesture locking ---------- */
// Add a "phone" class to <html> only for phones (not iPad/tablets).
(function detectPhone(){
  try {
    const ua = navigator.userAgent || '';
    const isMobileUa = /Mobi|Android/i.test(ua);
    const maxScreen = Math.max(screen.width || 0, screen.height || 0);
    // treat as phone if UA says mobile AND max screen dimension < 1024
    if(isMobileUa && maxScreen < 1024){
      document.documentElement.classList.add('phone');
    }
  } catch(e){}
})();

// Prevent touchmove (scroll/pinch) on everything except our allowed scroll containers.
// This makes the page behave more like a native app: only .conv-body and .rooms-list are scrollable.
document.addEventListener('touchmove', (ev) => {
  try {
    if(ev.target && ev.target.closest && (ev.target.closest('.conv-body') || ev.target.closest('.rooms-list') || ev.target.closest('input, textarea'))){
      return; // allow scrolling inside messages and rooms and inputs
    }
    ev.preventDefault();
  } catch (err) {}
}, { passive: false });

// Prevent double-tap -> zoom on iOS by blocking quick successive touchend events
let lastTouchTime = 0;
document.addEventListener('touchend', function(e){
  try {
    const now = Date.now();
    if (now - lastTouchTime <= 300) {
      e.preventDefault();
    }
    lastTouchTime = now;
  } catch (err) {}
}, { passive: false });

/* DOM refs */
const $roomsList = document.getElementById('roomsList');
const $newRoomBtn = document.getElementById('newRoomBtn');
const $currentRoomName = document.getElementById('currentRoomName');
const $messages = document.getElementById('messages');
const $form = document.getElementById('sendForm');
const $text = document.getElementById('text');
const $sendBtn = document.getElementById('sendBtn');
const $modalBackdrop = document.getElementById('modalBackdrop');
const $modal = document.getElementById('modal');
const $userControls = document.getElementById('userControls');
const $authControls = document.getElementById('authControls');
const $currentUserBadge = document.getElementById('currentUserBadge');

const $btnSignIn = document.getElementById('btnSignIn');
const $btnRegister = document.getElementById('btnRegister');

const $contextMenu = document.getElementById('contextMenu');
const $ctxOpen = document.getElementById('ctxOpen');
const $ctxRename = document.getElementById('ctxRename');
const $ctxInvite = document.getElementById('ctxInvite');
const $ctxDelete = document.getElementById('ctxDelete');

/* state */
let roomsCache = [];
let currentRoom = null;
let currentRoomId = null;
let currentRoomToken = null;
let channel = null;

/* local keys */
const LS_ROOMS = 'sb_chat_rooms_v1';
const LS_MESSAGES_PREFIX = 'sb_chat_messages_v1_';
const LS_ROOM_TOKEN = id => `room_token_${id}`;
const LS_OUTBOX = 'sb_chat_outbox_v1';

/* send guard */
let isSending = false;

/* helpers */
function nowIso(){ return new Date().toISOString(); }
function uid(){ if(window.crypto && crypto.randomUUID) return crypto.randomUUID(); return 'tmp-' + Date.now().toString(36); }
function formatTime(ts){ try{ return new Date(ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); }catch(e){ return ''; } }
function clampText(s, n){ if(!s) return ''; return s.length > n ? s.slice(0,n-1) + 'â€¦' : s; }

/* ---------- AUTH helpers (unchanged) ---------- */

async function getCurrentUser(){
  const { data } = await supabase.auth.getSession();
  return data?.session?.user ?? null;
}

async function loadProfileForUser(userId){
  if(!userId) return null;
  const { data, error } = await supabase.from('profiles').select('*').eq('id', userId).limit(1).single();
  if(error) {
    return null;
  }
  return data;
}

async function createProfile(userId, username){
  const { data, error } = await supabase.from('profiles').insert([{ id: userId, username }]).select();
  if(error) throw error;
  return data[0];
}

async function ensureProfile(user){
  if(!user) return null;
  let profile = await loadProfileForUser(user.id);
  if(profile) return profile;
  const defaultName = user.email ? user.email.split('@')[0] : `user-${Date.now().toString(36).slice(-6)}`;
  try {
    profile = await createProfile(user.id, defaultName);
    return profile;
  } catch(e) {
    return null;
  }
}

/* UI: render the top-right auth area based on session */
async function refreshAuthUI(){
  const user = (await getCurrentUser());
  if(!user){
    $userControls.style.display = 'flex';
    $authControls.innerHTML = '';
    $currentUserBadge.textContent = '';
    window.__AUTH_PROFILE_USERNAME = undefined; // clear
    return;
  }
  $userControls.style.display = 'none';
  const profile = await loadProfileForUser(user.id);
  const username = profile?.username ?? '(no username)';
  window.__AUTH_PROFILE_USERNAME = username;
  $authControls.innerHTML = '';
  const span = document.createElement('div'); span.textContent = username; span.style.fontWeight = '700';
  const signOutBtn = document.createElement('button'); signOutBtn.textContent = 'Sign out'; signOutBtn.className = 'btn ghost';
  signOutBtn.onclick = async () => { await supabase.auth.signOut(); await refreshAuthUI(); };
  $authControls.appendChild(span); $authControls.appendChild(signOutBtn);
  $currentUserBadge.textContent = `Signed in as ${username}`;
}

/* Registration flow (modal) */
$btnRegister.onclick = async ()=>{
  const res = await showRegisterModal();
  if(!res) return;
  const { username, email, password } = res;
  try{
    const { data, error } = await supabase.auth.signUp({ email, password });
    if(error){
      await showAlertModal('Registration failed: ' + (error.message || String(error)));
      return;
    }
    const user = data?.user ?? (await getCurrentUser());
    if(user){
      try{ await createProfile(user.id, username); } catch(profileErr){ await showAlertModal('Account created but username is taken. Please sign in and choose another username.'); }
    }
    await showAlertModal('Registration successful. If your email requires confirmation, check your inbox. You are now (possibly) signed in.');
    await refreshAuthUI();
  } catch(err){ console.error(err); await showAlertModal('Registration failed'); }
};

/* Sign-in flow */
$btnSignIn.onclick = async ()=>{
  const res = await showSignInModal();
  if(!res) return;
  const { email, password } = res;
  try{
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    if(error) { await showAlertModal('Sign-in failed: ' + (error.message || String(error))); return; }
    const user = data?.user ?? (await getCurrentUser());
    const profile = user ? await loadProfileForUser(user.id) : null;
    if(!profile){
      const username = await showInputModal({ title:'Pick a username', label:'Username', placeholder: email.split('@')[0] });
      if(username){
        try{ await createProfile(user.id, username); } catch(e){ await showAlertModal('Failed to set username. It may already be taken.'); }
      }
    }
    await refreshAuthUI();
    await loadRooms();
    if(currentRoomId) await loadMessagesForRoom(currentRoomId);
  } catch(err){ console.error(err); await showAlertModal('Sign-in failed'); }
};

/* ---------- Application logic (rooms + messages) with send-guard & composer padding ---------- */

/* caching helpers */
function saveRoomsToCache(rooms){ try{ localStorage.setItem(LS_ROOMS, JSON.stringify(rooms)); }catch(e){} }
function loadRoomsFromCache(){ try{ return JSON.parse(localStorage.getItem(LS_ROOMS) || 'null'); }catch(e){return null} }
function saveMessagesForRoom(roomId, msgs){ try{ localStorage.setItem(LS_MESSAGES_PREFIX + roomId, JSON.stringify(msgs)); }catch(e){} }
function loadMessagesForRoomCache(roomId){ try{ return JSON.parse(localStorage.getItem(LS_MESSAGES_PREFIX + roomId) || 'null'); }catch(e){return null} }
function persistRoomTokenLocally(roomId, token){ try{ localStorage.setItem(LS_ROOM_TOKEN(roomId), token || ''); }catch(e){} }
function getLocalRoomToken(roomId){ try{ return localStorage.getItem(LS_ROOM_TOKEN(roomId)) || null; }catch(e){return null} }

/* unread helpers */
function getUnreadCount(roomId){ try{ return parseInt(localStorage.getItem('unread_' + roomId) || '0', 10) || 0; }catch(e){return 0} }
function setUnreadCount(roomId, n){ try{ localStorage.setItem('unread_' + roomId, String(n)); }catch(e){} }
function incUnread(roomId){ setUnreadCount(roomId, getUnreadCount(roomId) + 1); }
function clearUnread(roomId){ setUnreadCount(roomId, 0); }

/* render rooms (with last snippet/unread) */
function getLastMessageForRoom(roomId){
  const msgs = loadMessagesForRoomCache(roomId);
  if(!msgs || !msgs.length) return null;
  return msgs[msgs.length - 1];
}
function renderRooms(list){
  $roomsList.innerHTML = '';
  list.forEach(r=>{
    const el = document.createElement('div');
    el.className = 'room-entry' + (currentRoomId === r.id ? ' active' : '');
    el.setAttribute('data-id', r.id);

    const avatar = document.createElement('div'); avatar.className='avatar'; avatar.textContent = (r.name||'?').split(/\s+/).map(s=>s[0]).slice(0,2).join('').toUpperCase();

    const info = document.createElement('div'); info.className='room-info';
    const nm = document.createElement('div'); nm.className='room-name';
    nm.textContent = r.name || 'Untitled';
    if (r.is_private) {
      const lock = document.createElement('span'); lock.textContent = ' ðŸ”’'; lock.style.opacity = '0.6'; nm.appendChild(lock);
    }
    const snippet = document.createElement('div'); snippet.className='last-snippet';
    const last = getLastMessageForRoom(r.id);
    if(last) snippet.textContent = clampText(last.content.replace(/\n/g,' '), 40); else snippet.textContent = 'No messages yet';
    info.appendChild(nm); info.appendChild(snippet);

    const meta = document.createElement('div'); meta.className='room-meta';
    const time = document.createElement('div'); time.className='last-time';
    time.textContent = last ? formatTime(last.created_at) : '';
    const unread = document.createElement('div'); unread.className='unread';
    const ucount = getUnreadCount(r.id);
    unread.textContent = ucount > 0 ? String(ucount > 99 ? '99+' : ucount) : '';
    if(ucount === 0) unread.style.display = 'none';
    meta.appendChild(time); meta.appendChild(unread);

    el.appendChild(avatar); el.appendChild(info); el.appendChild(meta);

    el.addEventListener('click', ()=> {
      joinRoom(r.id, null);
    });

    attachLongPressContext(el, r);
    $roomsList.appendChild(el);
  });
}

/* messages display */
function showEmptyConversation(){
  $messages.innerHTML = '';
  const wrap = document.createElement('div'); wrap.className = 'empty-illustration';
  wrap.innerHTML = `
    <svg width="160" height="100" viewBox="0 0 160 100" xmlns="http://www.w3.org/2000/svg">
      <rect x="6" y="6" width="148" height="88" rx="12" fill="currentColor"/>
    </svg>
    <h2>Start the conversation</h2>
    <p>Send the first message â€” it's private by default.</p>
  `;
  $messages.appendChild(wrap);
}

/* add message to DOM; determine "me" using authenticated profile or 'anon' */
function getLocalDisplayName(){
  return window.__AUTH_PROFILE_USERNAME || 'anon';
}

function addMessageDOM(m, opts={}){
  if(m.id && document.querySelector(`[data-id="${m.id}"]`)) return;
  if(opts.tempId){
    const existing = document.querySelector(`[data-temp-id="${opts.tempId}"]`);
    if(existing){
      const body = existing.querySelector('.body'); if(body) body.textContent = m.content;
      const meta = existing.querySelector('.meta'); if(meta) meta.textContent = (m.username||'anon') + ' â€¢ ' + formatTime(m.created_at||nowIso());
      const st = existing.querySelector('.timestamp'); if(st && opts.status) st.textContent = opts.status;
      return existing;
    }
  }
  const localName = getLocalDisplayName();
  const isMe = ((m.username||'').toLowerCase() === (localName||'').toLowerCase()) || opts.forceMe === true;
  const row = document.createElement('div'); row.className = 'msg-row' + (isMe ? ' me' : '');
  if(m.id) row.setAttribute('data-id', m.id);
  if(opts.tempId) row.setAttribute('data-temp-id', opts.tempId);

  const avatar = document.createElement('div'); avatar.className='avatar'; avatar.textContent = (m.username||'A').split(/\s+/).map(s=>s[0]).slice(0,2).join('').toUpperCase();
  const bubble = document.createElement('div'); bubble.className = 'bubble ' + (isMe ? 'right' : 'left');
  const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = (m.username||'anon') + ' â€¢ ' + formatTime(m.created_at||nowIso());
  const body = document.createElement('div'); body.className = 'body'; body.textContent = m.content;
  const ts = document.createElement('div'); ts.className = 'timestamp'; ts.textContent = opts.status || '';
  bubble.appendChild(meta); bubble.appendChild(body); bubble.appendChild(ts);
  row.appendChild(avatar); row.appendChild(bubble);

  const onlyEmpty = $messages.children.length === 1 && $messages.children[0].classList && $messages.children[0].classList.contains('empty-illustration');
  if(onlyEmpty) $messages.innerHTML = '';

  $messages.appendChild(row);
  $messages.scrollTop = $messages.scrollHeight;
  return row;
}
function clearMessages(){ $messages.innerHTML = ''; }

/* replace optimistic element with returned server row preserving alignment */
function replaceOptimisticWithReturned(tempId, returned){
  const el = document.querySelector(`[data-temp-id="${tempId}"]`);
  if(!el){
    addMessageDOM(returned); return;
  }

  // --- NEW: if realtime already added the returned.id, merge into that node and remove optimistic ---
  if(returned.id){
    const existing = document.querySelector(`[data-id="${returned.id}"]`);
    if(existing && existing !== el){
      // update existing node with freshest data
      const meta = existing.querySelector('.meta'); if(meta) meta.textContent = (returned.username||'anon') + ' â€¢ ' + formatTime(returned.created_at||nowIso());
      const body = existing.querySelector('.body'); if(body) body.textContent = returned.content;
      const ts = existing.querySelector('.timestamp'); if(ts) ts.textContent = '';
      // remove the optimistic placeholder
      el.remove();
      $messages.scrollTop = $messages.scrollHeight;
      return;
    }
  }
  // --- end NEW ---

  el.removeAttribute('data-temp-id');
  if(returned.id) el.setAttribute('data-id', returned.id);
  const meta = el.querySelector('.meta'); if(meta) meta.textContent = (returned.username||'anon') + ' â€¢ ' + formatTime(returned.created_at||nowIso());
  const body = el.querySelector('.body'); if(body) body.textContent = returned.content;
  const ts = el.querySelector('.timestamp'); if(ts) ts.textContent = '';
  const localName = getLocalDisplayName();
  if((returned.username||'').toLowerCase() === (localName||'').toLowerCase()){
    el.classList.add('me');
    const bubble = el.querySelector('.bubble'); if(bubble){ bubble.classList.remove('left'); bubble.classList.add('right'); }
  }
  $messages.scrollTop = $messages.scrollHeight;
}

/* composer padding adjustment so input doesn't get clipped by keyboard or OS bottom insets */
const $composer = document.querySelector('.composer');
function adjustComposerPadding(){
  try{
    const composerHeight = $composer ? $composer.offsetHeight : 0;
    // add some buffer so last message isn't hidden behind composer
    const buffer = 20;
    $messages.style.paddingBottom = (composerHeight + buffer) + 'px';
    // keep scrolled to bottom when composer changes
    $messages.scrollTop = $messages.scrollHeight;
  } catch(e) {}
}
window.addEventListener('resize', adjustComposerPadding);
window.addEventListener('orientationchange', adjustComposerPadding);
$text.addEventListener('focus', adjustComposerPadding);
$text.addEventListener('blur', adjustComposerPadding);
// call initially after DOM is ready
setTimeout(adjustComposerPadding, 150);

/* load rooms (cache-first) */
async function loadRooms(){
  try{
    const cached = loadRoomsFromCache(); if(cached){ roomsCache = cached; renderRooms(roomsCache); }
    if(!navigator.onLine) return;
    const { data, error } = await supabase.from('rooms').select('*').order('created_at',{ascending:true}).limit(500);
    if(error){ console.error('loadRooms', error); return; }
    roomsCache = data; saveRoomsToCache(data); renderRooms(data);
  } catch(err){ console.error(err); }
}

/* create-private-room modal */
$newRoomBtn.addEventListener('click', async ()=>{
  const name = await showInputModal({ title: 'New chat', label: 'Chat name', placeholder: 'Name this chat' });
  if(!name) return;
  try{
    const { data, error } = await supabase.from('rooms').insert([{ name, is_private: true }]).select();
    if(error){ console.error('create', error); await showAlertModal('Failed to create chat'); return; }
    await loadRooms();
    if(data && data[0]) await joinRoom(data[0].id, data[0].is_private ? data[0].invite_token : null);
  } catch(err){ console.error(err); await showAlertModal('Failed to create chat'); }
});

/* join room */
async function joinRoom(roomId, tokenFromUrl){
  if(!roomId) return;
  try{
    const { data, error } = await supabase.from('rooms').select('*').eq('id', roomId).limit(1).single();
    if(error){ console.error('joinRoom', error); await showAlertModal('Failed to join chat'); return; }
    currentRoom = data; currentRoomId = data.id;
    currentRoomToken = tokenFromUrl || getLocalRoomToken(roomId) || null;
    if(tokenFromUrl) persistRoomTokenLocally(roomId, tokenFromUrl);
    $currentRoomName.textContent = (data.name || 'Untitled') + (data.is_private ? ' ðŸ”’' : '');
    clearUnread(roomId);
    renderRooms(roomsCache);
    await loadMessagesForRoom(roomId);
    await subscribeRealtime();
  } catch(err){ console.error(err); await showAlertModal('Failed to join chat'); }
}

/* load messages for room (cache-first) */
async function loadMessagesForRoom(roomId){
  if(!roomId) return;
  clearMessages();
  const cached = loadMessagesForRoomCache(roomId);
  if(cached && cached.length){ cached.forEach(m => addMessageDOM(m)); }
  else showEmptyConversation();
  if(!navigator.onLine) return;
  try{
    const { data, error } = await supabase.from('messages').select('*').eq('room_id', roomId).order('created_at',{ascending:true}).limit(500);
    if(error){ console.error('loadMessagesForRoom', error); return; }
    if(!data || !data.length){ showEmptyConversation(); } else { clearMessages(); data.forEach(m => addMessageDOM(m)); saveMessagesForRoom(roomId, data); }
  } catch(err){ console.error(err); }
}

/* realtime subscription with protected unread logic */
async function subscribeRealtime(){
  try{ if(channel) await channel.unsubscribe(); }catch(e){}
  if(!currentRoomId || !navigator.onLine) return;
  channel = supabase.channel('public:messages')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, (payload)=>{
      const row = payload?.new; if(!row) return;
      const sameRoom = String(row.room_id) === String(currentRoomId);
      const localName = getLocalDisplayName();
      const fromLocalName = (row.username||'').toLowerCase() === (localName||'').toLowerCase();
      if(sameRoom){
        if(row.id && document.querySelector(`[data-id="${row.id}"]`)) return;
        addMessageDOM(row);
        const cached = loadMessagesForRoomCache(currentRoomId) || []; cached.push(row); saveMessagesForRoom(currentRoomId, cached);
      } else {
        if(!fromLocalName) incUnread(row.room_id);
        const msgs = loadMessagesForRoomCache(row.room_id) || []; msgs.push(row); saveMessagesForRoom(row.room_id, msgs);
        const roomIndex = roomsCache.findIndex(r=>String(r.id) === String(row.room_id));
        if(roomIndex !== -1) renderRooms(roomsCache);
      }
    });
  const { error } = await channel.subscribe();
  if(error) console.error('channel', error);
}

/* send message (auth-protected username) with isSending guard */
$sendBtn.addEventListener('click', async ()=> await sendMessage());
$form.addEventListener('submit', async (ev)=>{ ev.preventDefault(); await sendMessage(); });

// also send on Enter
$text.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    e.preventDefault();
    // guard to avoid triggering twice; sendMessage checks isSending
    sendMessage();
  }
});

async function sendMessage(){
  // guard: prevent multiple simultaneous sends
  if(isSending) return;
  const txt = $text.value.trim(); if(!txt) return;
  if(!currentRoomId){ await showAlertModal('Join a chat first'); return; }

  isSending = true;
  $sendBtn.disabled = true;
  $sendBtn.setAttribute('aria-busy', 'true');

  // determine username: if user signed in, use profile username; else guest 'anon'
  const user = await getCurrentUser();
  let username = 'anon';
  if(user){
    const profile = await loadProfileForUser(user.id);
    username = profile?.username ?? (user.email ? user.email.split('@')[0] : 'anon');
    window.__AUTH_PROFILE_USERNAME = username; // keep up-to-date
    await refreshAuthUI();
  } else {
    username = 'anon';
  }

  $text.value = '';
  const tempId = uid();
  const optimistic = { username, content: txt, created_at: nowIso() };

  // remove empty illustration
  const onlyEmpty = $messages.children.length === 1 && $messages.children[0].classList && $messages.children[0].classList.contains('empty-illustration');
  if(onlyEmpty) clearMessages();

  // optimistic (forceMe)
  addMessageDOM(optimistic, { tempId, status: 'sendingâ€¦', forceMe: true });
  adjustComposerPadding(); // adjust padding after inserting optimistic message

  const insertPayload = { content: txt, username, room_id: currentRoomId };
  if(currentRoomToken) insertPayload.room_token = currentRoomToken;

  try{
    if(!navigator.onLine){
      const q = JSON.parse(localStorage.getItem(LS_OUTBOX) || '[]'); q.push(insertPayload); localStorage.setItem(LS_OUTBOX, JSON.stringify(q));
      const optimisticEl = document.querySelector(`[data-temp-id="${tempId}"]`);
      if(optimisticEl){ const ts = optimisticEl.querySelector('.timestamp'); if(ts) ts.textContent = 'queued offline'; }
      updateRoomLastMessage(currentRoomId, insertPayload);
      return;
    }
    const { data, error } = await supabase.from('messages').insert([insertPayload]).select();
    if(error){
      console.error('send', error);
      const el = document.querySelector(`[data-temp-id="${tempId}"]`);
      if(el){ const ts = el.querySelector('.timestamp'); if(ts) ts.textContent = 'failed'; }
      const q = JSON.parse(localStorage.getItem(LS_OUTBOX) || '[]'); q.push(insertPayload); localStorage.setItem(LS_OUTBOX, JSON.stringify(q));
      updateRoomLastMessage(currentRoomId, insertPayload);
      return;
    }
    if(data && data[0]){
      const returned = data[0];
      replaceOptimisticWithReturned(tempId, returned);
      const cached = loadMessagesForRoomCache(currentRoomId) || []; cached.push(returned); saveMessagesForRoom(currentRoomId, cached);
      updateRoomLastMessage(currentRoomId, returned);
    }
  } catch(err){
    console.error(err);
    const q = JSON.parse(localStorage.getItem(LS_OUTBOX) || '[]'); q.push(insertPayload); localStorage.setItem(LS_OUTBOX, JSON.stringify(q));
    updateRoomLastMessage(currentRoomId, insertPayload);
  } finally {
    isSending = false;
    $sendBtn.disabled = false;
    $sendBtn.removeAttribute('aria-busy');
    adjustComposerPadding();
  }
}

/* update room last message snippet and rerender rooms */
function updateRoomLastMessage(roomId, message){
  const cached = loadMessagesForRoomCache(roomId) || [];
  cached.push({ ...message, created_at: message.created_at || nowIso() });
  saveMessagesForRoom(roomId, cached);
  renderRooms(roomsCache);
}

/* outbox flush on reconnect (keeps old behavior) */
async function flushOutbox(){
  if(!navigator.onLine) return;
  const q = JSON.parse(localStorage.getItem(LS_OUTBOX) || '[]');
  if(!q.length) return;
  const remaining = [];
  for(const item of q){
    try{
      const { data, error } = await supabase.from('messages').insert([item]).select();
      if(error || !data || !data[0]) remaining.push(item);
      else {
        const cached = loadMessagesForRoomCache(item.room_id) || [];
        cached.push(data[0]); saveMessagesForRoom(item.room_id, cached);
      }
    } catch(err){ remaining.push(item); }
  }
  localStorage.setItem(LS_OUTBOX, JSON.stringify(remaining));
}
window.addEventListener('online', async ()=>{ await flushOutbox(); if(currentRoomId) { await loadMessagesForRoom(currentRoomId); await subscribeRealtime(); } });

/* invite link helper */
async function showInviteLink(room){
  try{
    const { data, error } = await supabase.from('rooms').select('id, name, is_private, invite_token').eq('id', room.id).limit(1).single();
    if(error){ console.error('invite fetch', error); await showAlertModal('failed to create invite'); return; }
    const tokenPart = data.is_private ? `&token=${encodeURIComponent(data.invite_token)}` : '';
    const link = `${location.origin}${location.pathname}?room=${data.id}${tokenPart}`;
    await navigator.clipboard.writeText(link);
    await showAlertModal('Invite link copied to clipboard');
  } catch(e){ console.error(e); await showAlertModal('Failed to create invite'); }
}

/* long-press / context menu (unchanged) */
function attachLongPressContext(el, room){
  let pressTimer = null; let touchPos = {x:0,y:0};
  const menu = $contextMenu;
  const showAt = (x,y)=>{
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
    menu.style.display = 'block';
    const rect = menu.getBoundingClientRect(); let left = x, top = y;
    if(left + rect.width > vw) left = vw - rect.width - 12;
    if(top + rect.height > vh) top = vh - rect.height - 12;
    menu.style.left = left + 'px'; menu.style.top = top + 'px';
    menu.setAttribute('data-room-id', room.id); menu.setAttribute('aria-hidden','false');
  };
  const hide = ()=>{ menu.style.display='none'; menu.removeAttribute('data-room-id'); menu.setAttribute('aria-hidden','true'); };

  el.addEventListener('touchstart', (e)=>{ if(e.touches.length > 1) return; const t = e.touches[0]; touchPos.x = t.clientX; touchPos.y = t.clientY; pressTimer = setTimeout(()=>{ showAt(touchPos.x, touchPos.y); }, 600); }, {passive:true});
  el.addEventListener('touchend', ()=>{ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } }, {passive:true});
  el.addEventListener('touchmove', ()=>{ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } }, {passive:true});
  el.addEventListener('contextmenu', (ev)=>{ ev.preventDefault(); showAt(ev.clientX, ev.clientY); });

  document.addEventListener('click', (ev)=>{ if(!ev.target.closest('.context-menu')) hide(); });
  window.addEventListener('scroll', hide);

  $ctxOpen.onclick = ()=>{ const id = menu.getAttribute('data-room-id'); if(id){ hide(); joinRoom(id,null);} };
  $ctxRename.onclick = async ()=> { const id = menu.getAttribute('data-room-id'); if(!id) return; hide(); const current = roomsCache.find(r=>r.id===id); const newName = await showInputModal({ title: 'Rename chat', label:'New name', placeholder: current ? current.name : '' }); if(!newName) return; try{ const { data, error } = await supabase.from('rooms').update({ name: newName }).eq('id', id).select(); if(error){ console.error('rename error', error); await showAlertModal('Failed to rename'); return; } roomsCache = roomsCache.map(r => r.id===id ? {...r, name:newName} : r); saveRoomsToCache(roomsCache); renderRooms(roomsCache); if(currentRoomId === id) $currentRoomName.textContent = newName; } catch(err){ console.error(err); await showAlertModal('Failed to rename'); } };
  $ctxInvite.onclick = async ()=> { const id = menu.getAttribute('data-room-id'); if(!id) return; hide(); const roomObj = roomsCache.find(r=>r.id===id); if(roomObj) return showInviteLink(roomObj); try{ const { data, error } = await supabase.from('rooms').select('id, name, is_private, invite_token').eq('id', id).limit(1).single(); if(error) throw error; const tokenPart = data.is_private ? `&token=${encodeURIComponent(data.invite_token)}` : ''; const link = `${location.origin}${location.pathname}?room=${data.id}${tokenPart}`; await navigator.clipboard.writeText(link); await showAlertModal('Invite link copied to clipboard'); } catch(e){ console.error(e); await showAlertModal('Failed to create invite'); } };
  $ctxDelete.onclick = async ()=> { const id = menu.getAttribute('data-room-id'); if(!id) return; hide(); const ok = await showConfirmModal('Delete chat', 'Delete this chat? This will remove it from the server.'); if(!ok) return; try{ const { error } = await supabase.from('rooms').delete().eq('id', id); if(error){ console.error('delete', error); await showAlertModal('Failed to delete'); return; } roomsCache = roomsCache.filter(r => r.id !== id); saveRoomsToCache(roomsCache); localStorage.removeItem(LS_MESSAGES_PREFIX + id); localStorage.removeItem('unread_' + id); if(currentRoomId === id){ currentRoomId = null; currentRoom = null; clearMessages(); $currentRoomName.textContent = 'â€”'; showEmptyConversation(); } renderRooms(roomsCache); await showAlertModal('Chat deleted'); } catch(err){ console.error(err); await showAlertModal('Failed to delete'); } };
}

/* Modal utilities (promise-based) */
function showModalHtml(html){ $modal.innerHTML = html; $modalBackdrop.style.display = 'flex'; $modalBackdrop.setAttribute('aria-hidden','false'); return; }
function closeModal(){ $modalBackdrop.style.display = 'none'; $modalBackdrop.setAttribute('aria-hidden','true'); $modal.innerHTML = ''; }

/* Register modal: collects username, email, password */
function showRegisterModal(){
  return new Promise((resolve)=>{
    showModalHtml(`<h3>Register</h3>
      <div class="row"><label style="font-weight:700">Username</label></div>
      <div class="row"><input id="reg_username" type="text" placeholder="your-username" /></div>
      <div class="row"><label style="font-weight:700">Email</label></div>
      <div class="row"><input id="reg_email" type="email" placeholder="you@example.com" /></div>
      <div class="row"><label style="font-weight:700">Password</label></div>
      <div class="row"><input id="reg_password" type="password" placeholder="password" /></div>
      <div class="btns"><button class="btn secondary" id="reg_cancel">Cancel</button><button class="btn primary" id="reg_ok">Register</button></div>`);
    const $ok = document.getElementById('reg_ok'), $cancel = document.getElementById('reg_cancel');
    $cancel.onclick = ()=> { closeModal(); resolve(null); };
    $ok.onclick = ()=> {
      const username = document.getElementById('reg_username').value.trim();
      const email = document.getElementById('reg_email').value.trim();
      const password = document.getElementById('reg_password').value;
      closeModal(); resolve({ username, email, password });
    };
  });
}

/* Sign-in modal: email + password */
function showSignInModal(){
  return new Promise((resolve)=>{
    showModalHtml(`<h3>Sign in</h3>
      <div class="row"><label style="font-weight:700">Email</label></div>
      <div class="row"><input id="si_email" type="email" placeholder="you@example.com" /></div>
      <div class="row"><label style="font-weight:700">Password</label></div>
      <div class="row"><input id="si_password" type="password" placeholder="password" /></div>
      <div class="btns"><button class="btn secondary" id="si_cancel">Cancel</button><button class="btn primary" id="si_ok">Sign in</button></div>`);
    document.getElementById('si_cancel').onclick = ()=> { closeModal(); resolve(null); };
    document.getElementById('si_ok').onclick = ()=> {
      const email = document.getElementById('si_email').value.trim();
      const password = document.getElementById('si_password').value;
      closeModal(); resolve({ email, password });
    };
  });
}

function showInputModal({ title = 'Input', label = '', placeholder = '' }){
  return new Promise((resolve)=>{
    showModalHtml(`<h3>${escapeHtml(title)}</h3>
      <div class="row"><label style="font-weight:700">${escapeHtml(label)}</label></div>
      <div class="row"><input id="modalInput" type="text" placeholder="${escapeHtml(placeholder)}" /></div>
      <div class="btns"><button class="btn secondary" id="modalCancel">Cancel</button><button class="btn primary" id="modalOk">OK</button></div>`);
    const $input = document.getElementById('modalInput'); const $ok = document.getElementById('modalOk'); const $cancel = document.getElementById('modalCancel');
    $input.focus();
    $ok.onclick = ()=> { closeModal(); resolve($input.value.trim() || null); };
    $cancel.onclick = ()=> { closeModal(); resolve(null); };
    $input.addEventListener('keydown', (e)=> { if(e.key === 'Enter') $ok.click(); if(e.key === 'Escape') $cancel.click(); });
  });
}
function showConfirmModal(title, message){
  return new Promise((resolve)=>{
    showModalHtml(`<h3>${escapeHtml(title)}</h3><p style="color:var(--muted);margin-top:8px">${escapeHtml(message)}</p><div class="btns"><button class="btn secondary" id="modalNo">Cancel</button><button class="btn primary" id="modalYes">Delete</button></div>`);
    document.getElementById('modalYes').onclick = ()=> { closeModal(); resolve(true); };
    document.getElementById('modalNo').onclick = ()=> { closeModal(); resolve(false); };
  });
}
function showAlertModal(message){
  return new Promise((resolve)=>{
    showModalHtml(`<h3>Notice</h3><p style="color:var(--muted);margin-top:8px">${escapeHtml(message)}</p><div class="btns"><button class="btn primary" id="modalOk">OK</button></div>`);
    document.getElementById('modalOk').onclick = ()=> { closeModal(); resolve(); };
  });
}

function escapeHtml(s){ return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

/* start up */
(async function init(){
  // refresh auth UI
  await refreshAuthUI();

  // quick cached rooms
  const cached = loadRoomsFromCache(); if(cached){ roomsCache = cached; renderRooms(roomsCache); }
  await loadRooms();

  // autoparse URL invite token
  const params = new URLSearchParams(location.search);
  const room = params.get('room'); const token = params.get('token'); if(room && token) persistRoomTokenLocally(room, token);
  if(room) await joinRoom(room, token); else if(roomsCache[0]) await joinRoom(roomsCache[0].id, getLocalRoomToken(roomsCache[0].id));

  // adjust composer padding at start
  setTimeout(adjustComposerPadding, 200);

  // hide modal on backdrop click
  $modalBackdrop.addEventListener('click', (ev)=>{ if(ev.target === $modalBackdrop){ closeModal(); }});
})();

/* ---------- PWA manifest + service worker minimal ---------- */
const manifestData = { name:'Yap', short_name:'Yap', start_url:'.', display:'standalone', background_color:'#071023', theme_color:'#071023', icons:[{ src:'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="192" height="192"><rect width="100%" height="100%" rx="28" fill="#06b6d4"/><text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" font-size="74" font-family="Arial" fill="#012335">Y</text></svg>`), sizes:'192x192', type:'image/svg+xml' }] };
const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: 'application/json' });
const manifestURL = URL.createObjectURL(manifestBlob);
document.getElementById('manifest-placeholder').setAttribute('href', manifestURL);
const swCode = `const CACHE_NAME='yap-chat-v1';self.addEventListener('install',e=>{self.skipWaiting();});self.addEventListener('activate',e=>{e.waitUntil(self.clients.claim());});self.addEventListener('fetch',e=>{if(e.request.method!=='GET') return; e.respondWith(caches.match(e.request).then(r=>r || fetch(e.request).then(res=>{try{const c=res.clone(); caches.open(CACHE_NAME).then(cache=>cache.put(e.request, c));}catch(err){} return res;})).catch(()=>{}));});`;
const swBlob = new Blob([swCode], { type: 'application/javascript' });
const swURL = URL.createObjectURL(swBlob);
if('serviceWorker' in navigator){ navigator.serviceWorker.register(swURL).then(()=>console.log('sw registered')).catch(e=>console.warn('sw failed', e)); }

</script>
</body>
</html>

<!-- same top-of-file as before, omitted for brevity -->
<!-- Paste the rest of your original HTML but replace the following JS parts exactly as shown. -->
<script type="module">
/* ... earlier code unchanged ... */

/* add message to DOM; determine "me" using authenticated profile or 'anon' */
function getLocalDisplayName(){
  return window.__AUTH_PROFILE_USERNAME || 'anon';
}

function addMessageDOM(m, opts={}){
  // --- DEDUP: if this is an optimistic message (no id) and we already have one with the same content, reuse it ---
  if(!m.id){
    const pending = Array.from(document.querySelectorAll('[data-temp-id]'));
    for(const el of pending){
      const body = el.querySelector('.body');
      const meta = el.querySelector('.meta');
      const existingContent = body ? body.textContent : '';
      const existingUser = meta ? (meta.textContent.split(' â€¢ ')[0] || '') : '';
      const username = m.username || 'anon';
      if(existingContent === (m.content || '') && existingUser === username){
        // update and return existing optimistic node (prevents duplicates)
        if(body) body.textContent = m.content;
        if(meta) meta.textContent = (m.username||'anon') + ' â€¢ ' + formatTime(m.created_at||nowIso());
        const ts = el.querySelector('.timestamp'); if(ts && opts.status) ts.textContent = opts.status;
        return el;
      }
    }
  }

  if(m.id && document.querySelector(`[data-id="${m.id}"]`)) return;
  if(opts.tempId){
    const existing = document.querySelector(`[data-temp-id="${opts.tempId}"]`);
    if(existing){
      const body = existing.querySelector('.body'); if(body) body.textContent = m.content;
      const meta = existing.querySelector('.meta'); if(meta) meta.textContent = (m.username||'anon') + ' â€¢ ' + formatTime(m.created_at||nowIso());
      const st = existing.querySelector('.timestamp'); if(st && opts.status) st.textContent = opts.status;
      return existing;
    }
  }
  const localName = getLocalDisplayName();
  const isMe = ((m.username||'').toLowerCase() === (localName||'').toLowerCase()) || opts.forceMe === true;
  const row = document.createElement('div'); row.className = 'msg-row' + (isMe ? ' me' : '');
  if(m.id) row.setAttribute('data-id', m.id);
  if(opts.tempId) row.setAttribute('data-temp-id', opts.tempId);

  const avatar = document.createElement('div'); avatar.className='avatar'; avatar.textContent = (m.username||'A').split(/\s+/).map(s=>s[0]).slice(0,2).join('').toUpperCase();
  const bubble = document.createElement('div'); bubble.className = 'bubble ' + (isMe ? 'right' : 'left');
  const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = (m.username||'anon') + ' â€¢ ' + formatTime(m.created_at||nowIso());
  const body = document.createElement('div'); body.className = 'body'; body.textContent = m.content;
  const ts = document.createElement('div'); ts.className = 'timestamp'; ts.textContent = opts.status || '';
  bubble.appendChild(meta); bubble.appendChild(body); bubble.appendChild(ts);
  row.appendChild(avatar); row.appendChild(bubble);

  const onlyEmpty = $messages.children.length === 1 && $messages.children[0].classList && $messages.children[0].classList.contains('empty-illustration');
  if(onlyEmpty) $messages.innerHTML = '';

  $messages.appendChild(row);
  $messages.scrollTop = $messages.scrollHeight;
  return row;
}

/* ... other code unchanged ... */

/* also send on Enter â€” safer: ignore composition and repeated events to avoid double-send */
$text.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !e.isComposing && !e.repeat){
    e.preventDefault();
    // guard to avoid triggering twice; sendMessage checks isSending
    sendMessage();
  }
});

/* send message (auth-protected username) with isSending guard */
$sendBtn.addEventListener('click', async ()=> await sendMessage());
$form.addEventListener('submit', async (ev)=>{ ev.preventDefault(); await sendMessage(); });

async function sendMessage(){
  // guard: prevent multiple simultaneous sends
  if(isSending) return;
  const txt = $text.value.trim(); if(!txt) return;
  if(!currentRoomId){ await showAlertModal('Join a chat first'); return; }

  // mark sending immediately (prevents most races like double-click or duplicate key events)
  isSending = true;
  $sendBtn.disabled = true;
  $sendBtn.setAttribute('aria-busy', 'true');

  // QUICK DEDUPE: if an optimistic message with the same content already exists, abort this second send.
  try{
    const pending = Array.from(document.querySelectorAll('[data-temp-id]'));
    const already = pending.some(el => {
      const body = el.querySelector('.body');
      return (body && body.textContent === txt);
    });
    if(already){
      // re-enable UI and exit early
      isSending = false;
      $sendBtn.disabled = false;
      $sendBtn.removeAttribute('aria-busy');
      $text.value = ''; // clear to give feedback
      return;
    }
  } catch(e){ /* ignore dedupe failures and continue */ }

  // determine username: if user signed in, use profile username; else guest 'anon'
  const user = await getCurrentUser();
  let username = 'anon';
  if(user){
    const profile = await loadProfileForUser(user.id);
    username = profile?.username ?? (user.email ? user.email.split('@')[0] : 'anon');
    window.__AUTH_PROFILE_USERNAME = username; // keep up-to-date
    await refreshAuthUI();
  } else {
    username = 'anon';
  }

  $text.value = '';
  const tempId = uid();
  const optimistic = { username, content: txt, created_at: nowIso() };

  // remove empty illustration
  const onlyEmpty = $messages.children.length === 1 && $messages.children[0].classList && $messages.children[0].classList.contains('empty-illustration');
  if(onlyEmpty) clearMessages();

  // optimistic (forceMe)
  addMessageDOM(optimistic, { tempId, status: 'sendingâ€¦', forceMe: true });
  adjustComposerPadding(); // adjust padding after inserting optimistic message

  const insertPayload = { content: txt, username, room_id: currentRoomId };
  if(currentRoomToken) insertPayload.room_token = currentRoomToken;

  try{
    if(!navigator.onLine){
      const q = JSON.parse(localStorage.getItem(LS_OUTBOX) || '[]'); q.push(insertPayload); localStorage.setItem(LS_OUTBOX, JSON.stringify(q));
      const optimisticEl = document.querySelector(`[data-temp-id="${tempId}"]`);
      if(optimisticEl){ const ts = optimisticEl.querySelector('.timestamp'); if(ts) ts.textContent = 'queued offline'; }
      updateRoomLastMessage(currentRoomId, insertPayload);
      return;
    }
    const { data, error } = await supabase.from('messages').insert([insertPayload]).select();
    if(error){
      console.error('send', error);
      const el = document.querySelector(`[data-temp-id="${tempId}"]`);
      if(el){ const ts = el.querySelector('.timestamp'); if(ts) ts.textContent = 'failed'; }
      const q = JSON.parse(localStorage.getItem(LS_OUTBOX) || '[]'); q.push(insertPayload); localStorage.setItem(LS_OUTBOX, JSON.stringify(q));
      updateRoomLastMessage(currentRoomId, insertPayload);
      return;
    }
    if(data && data[0]){
      const returned = data[0];
      replaceOptimisticWithReturned(tempId, returned);
      const cached = loadMessagesForRoomCache(currentRoomId) || []; cached.push(returned); saveMessagesForRoom(currentRoomId, cached);
      updateRoomLastMessage(currentRoomId, returned);
    }
  } catch(err){
    console.error(err);
    const q = JSON.parse(localStorage.getItem(LS_OUTBOX) || '[]'); q.push(insertPayload); localStorage.setItem(LS_OUTBOX, JSON.stringify(q));
    updateRoomLastMessage(currentRoomId, insertPayload);
  } finally {
    isSending = false;
    $sendBtn.disabled = false;
    $sendBtn.removeAttribute('aria-busy');
    adjustComposerPadding();
  }
}

/* ... rest of your code unchanged ... */

</script>
